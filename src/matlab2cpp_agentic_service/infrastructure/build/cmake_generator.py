"""
CMakeLists.txt Generator for MATLAB to C++ Conversion Projects.

This module generates professional CMakeLists.txt files that:
- Automatically detect and link only needed helper libraries
- Support both single-file and multi-file projects
- Provide modern CMake best practices
- Enable IDE integration and debugging
"""

from pathlib import Path
from typing import Dict, List, Set
import logging


class CMakeGenerator:
    """Generate CMakeLists.txt for converted C++ projects."""
    
    def __init__(self):
        self.logger = logging.getLogger(__name__)
    
    def generate_cmake_file(self,
                           project_name: str,
                           generated_files: Dict[str, str],
                           is_multi_file: bool = False) -> str:
        """
        Generate a complete CMakeLists.txt file.
        
        Args:
            project_name: Name of the project (e.g., 'arma_filter', 'skeleton_vessel')
            generated_files: Dict mapping filenames to their content
            is_multi_file: Whether this is a multi-file project
        
        Returns:
            Complete CMakeLists.txt content as string
        """
        self.logger.info(f"Generating CMakeLists.txt for project: {project_name}")
        
        # Analyze project structure
        header_files = [f for f in generated_files.keys() if f.endswith('.h')]
        source_files = [f for f in generated_files.keys() if f.endswith('.cpp') and f != 'main.cpp']
        helper_files = self._identify_helper_files(generated_files)
        
        # Generate CMake content
        cmake_content = self._generate_cmake_header(project_name)
        cmake_content += self._generate_find_packages()
        cmake_content += self._generate_helper_libraries(helper_files)
        cmake_content += self._generate_project_library(project_name, header_files, source_files, is_multi_file)
        cmake_content += self._generate_executable(project_name, helper_files)
        cmake_content += self._generate_install_targets(project_name)
        
        self.logger.info(f"âœ… Generated CMakeLists.txt: {len(cmake_content)} bytes")
        return cmake_content
    
    def _identify_helper_files(self, generated_files: Dict[str, str]) -> Dict[str, List[str]]:
        """
        Identify which helper libraries are present in generated files.
        
        Returns:
            Dict mapping helper library names to their file lists
        """
        helpers = {}
        
        helper_patterns = {
            'tensor_helpers': ['tensor_helpers.h', 'tensor_helpers.cpp'],
            'rk4_helpers': ['rk4_helpers.h', 'rk4_helpers.cpp'],
            'matlab_image_helpers': ['matlab_image_helpers.h', 'matlab_image_helpers.cpp'],
            'msfm_helpers': ['msfm_helpers.h', 'msfm_helpers.cpp'],
            'matlab_array_utils': ['matlab_array_utils.h', 'matlab_array_utils.cpp'],
        }
        
        for helper_name, file_list in helper_patterns.items():
            if all(f in generated_files for f in file_list):
                helpers[helper_name] = file_list
                self.logger.debug(f"  Found helper: {helper_name}")
        
        self.logger.info(f"ðŸ“¦ Identified {len(helpers)} helper libraries")
        return helpers
    
    def _generate_cmake_header(self, project_name: str) -> str:
        """Generate CMake file header with version and project declaration."""
        return f'''# CMakeLists.txt for {project_name}
# Auto-generated by matlab2cpp_agentic_service
# ==========================================

cmake_minimum_required(VERSION 3.15)
project({project_name} VERSION 1.0.0 LANGUAGES CXX)

# C++ Standard
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Compiler warnings
if(MSVC)
    add_compile_options(/W4)
else()
    add_compile_options(-Wall -Wextra -Wpedantic)
endif()

# Optimization flags
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()

'''
    
    def _generate_find_packages(self) -> str:
        """Generate find_package commands for dependencies."""
        return '''# ==========================================
# Find Dependencies
# ==========================================

# Find Eigen3 (required)
find_package(Eigen3 3.3 REQUIRED NO_MODULE)
if(NOT Eigen3_FOUND)
    message(FATAL_ERROR "Eigen3 not found. Please install: sudo apt-get install libeigen3-dev")
endif()
message(STATUS "Found Eigen3: ${EIGEN3_INCLUDE_DIR}")

'''
    
    def _generate_helper_libraries(self, helper_files: Dict[str, List[str]]) -> str:
        """Generate OBJECT libraries for each helper."""
        if not helper_files:
            return "# No helper libraries in this project\n\n"
        
        content = '''# ==========================================
# Helper Libraries (as OBJECT libraries)
# ==========================================
# OBJECT libraries are compiled once and reused
# CMake automatically links only what's needed
#
'''
        
        for helper_name, files in helper_files.items():
            header = [f for f in files if f.endswith('.h')][0]
            source = [f for f in files if f.endswith('.cpp')][0]
            
            content += f'''# {helper_name}
add_library({helper_name} OBJECT
    {header}
    {source}
)
target_link_libraries({helper_name} PUBLIC Eigen3::Eigen)
target_include_directories({helper_name} PUBLIC ${{CMAKE_CURRENT_SOURCE_DIR}})

'''
        
        return content
    
    def _generate_project_library(self, 
                                  project_name: str,
                                  header_files: List[str],
                                  source_files: List[str],
                                  is_multi_file: bool) -> str:
        """Generate the main project library."""
        # Filter out helper files and main.cpp
        project_headers = [h for h in header_files if not any(helper in h for helper in 
                          ['tensor_helpers', 'rk4_helpers', 'matlab_image_helpers', 'msfm_helpers', 'matlab_array_utils'])]
        project_sources = [s for s in source_files if not any(helper in s for helper in 
                          ['tensor_helpers', 'rk4_helpers', 'matlab_image_helpers', 'msfm_helpers', 'matlab_array_utils'])]
        
        if is_multi_file:
            content = f'''# ==========================================
# Main Project Library (Multi-File Project)
# ==========================================

add_library({project_name}_lib
'''
            # Add all project files
            for header in project_headers:
                content += f'    {header}\n'
            for source in project_sources:
                content += f'    {source}\n'
            
            content += ''')
target_link_libraries({project_name}_lib PUBLIC Eigen3::Eigen)
target_include_directories({project_name}_lib PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})

'''.format(project_name=project_name)
        else:
            # Single-file project
            content = f'''# ==========================================
# Main Project Library (Single-File Project)
# ==========================================

add_library({project_name}_lib
'''
            for header in project_headers:
                content += f'    {header}\n'
            for source in project_sources:
                content += f'    {source}\n'
            
            content += f''')
target_link_libraries({project_name}_lib PUBLIC Eigen3::Eigen)
target_include_directories({project_name}_lib PUBLIC ${{CMAKE_CURRENT_SOURCE_DIR}})

'''
        
        return content
    
    def _generate_executable(self, project_name: str, helper_files: Dict[str, List[str]]) -> str:
        """Generate the test executable."""
        content = f'''# ==========================================
# Test Executable
# ==========================================

add_executable({project_name}_test main.cpp)

# Link project library
target_link_libraries({project_name}_test PRIVATE {project_name}_lib)

# Link Eigen
target_link_libraries({project_name}_test PRIVATE Eigen3::Eigen)

'''
        
        # Add helper libraries
        if helper_files:
            content += '''# Link helper libraries
# CMake will automatically include only the helpers that are actually used
'''
            for helper_name in helper_files.keys():
                content += f'target_link_libraries({project_name}_test PRIVATE {helper_name})\n'
            content += '\n'
        
        # Add include directories
        content += f'''# Include directories
target_include_directories({project_name}_test PRIVATE ${{CMAKE_CURRENT_SOURCE_DIR}})

'''
        
        return content
    
    def _generate_install_targets(self, project_name: str) -> str:
        """Generate install targets for deployment."""
        return f'''# ==========================================
# Install Targets (optional)
# ==========================================

install(TARGETS {project_name}_test
    RUNTIME DESTINATION bin
)

install(TARGETS {project_name}_lib
    LIBRARY DESTINATION lib
    ARCHIVE DESTINATION lib
)

# ==========================================
# Summary
# ==========================================

message(STATUS "=====================================================")
message(STATUS "Project: {project_name}")
message(STATUS "Build Type: ${{CMAKE_BUILD_TYPE}}")
message(STATUS "C++ Standard: ${{CMAKE_CXX_STANDARD}}")
message(STATUS "Eigen3 Include: ${{EIGEN3_INCLUDE_DIR}}")
message(STATUS "=====================================================")
'''


def generate_cmake_file(project_name: str, 
                       generated_files: Dict[str, str],
                       is_multi_file: bool = False) -> str:
    """
    Convenience function to generate CMakeLists.txt.
    
    Args:
        project_name: Name of the project
        generated_files: Dict of filename -> content
        is_multi_file: Whether this is a multi-file project
    
    Returns:
        CMakeLists.txt content as string
    
    Example:
        >>> cmake_content = generate_cmake_file(
        ...     'arma_filter',
        ...     {'arma_filter.h': '...', 'arma_filter.cpp': '...', 'main.cpp': '...'},
        ...     is_multi_file=False
        ... )
    """
    generator = CMakeGenerator()
    return generator.generate_cmake_file(project_name, generated_files, is_multi_file)

